From 11f1650c4784dea50a5c99d7aa445ef8b994345e Mon Sep 17 00:00:00 2001
From: Jouni Ukkonen <jouni.ukkonen@unikie.com>
Date: Fri, 10 Dec 2021 09:59:56 +0200
Subject: [PATCH 2/2] Buildroot: Sample application

Sample application to access seL4TEE

Signed-off-by: Jouni Ukkonen <jouni.ukkonen@unikie.com>
---
 package/Config.in                     |   1 +
 package/soc_example/Config.in         |   5 +
 package/soc_example/soc_example.mk    |  19 ++
 package/soc_example/src/Makefile      |  13 +
 package/soc_example/src/ree_tee_msg.h | 126 ++++++++++
 package/soc_example/src/sel4_test.c   | 338 ++++++++++++++++++++++++++
 6 files changed, 502 insertions(+)
 create mode 100644 package/soc_example/Config.in
 create mode 100644 package/soc_example/soc_example.mk
 create mode 100644 package/soc_example/src/Makefile
 create mode 100644 package/soc_example/src/ree_tee_msg.h
 create mode 100644 package/soc_example/src/sel4_test.c

diff --git a/package/Config.in b/package/Config.in
index 76520e13ba..16a02645d8 100644
--- a/package/Config.in
+++ b/package/Config.in
@@ -4,6 +4,7 @@ menu "Target packages"
 	source "package/skeleton/Config.in"
 	source "package/skeleton-custom/Config.in"
 	source "package/skeleton-init-common/Config.in"
+	source "package/soc_example/Config.in"
 	source "package/skeleton-init-none/Config.in"
 	source "package/skeleton-init-openrc/Config.in"
 	source "package/skeleton-init-systemd/Config.in"
diff --git a/package/soc_example/Config.in b/package/soc_example/Config.in
new file mode 100644
index 0000000000..cc1da6753b
--- /dev/null
+++ b/package/soc_example/Config.in
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_SOC_EXAMPLE
+    bool "Soc Example"
+    help
+        Polarfire system controller example
+
diff --git a/package/soc_example/soc_example.mk b/package/soc_example/soc_example.mk
new file mode 100644
index 0000000000..490d3be6bb
--- /dev/null
+++ b/package/soc_example/soc_example.mk
@@ -0,0 +1,19 @@
+################################################################################
+#
+# SOC_EXAMPLE
+#
+################################################################################
+
+SOC_EXAMPLE_VERSION = 1.0
+SOC_EXAMPLE_SITE = ./package/soc_example/src
+SOC_EXAMPLE_SITE_METHOD = local
+
+define SOC_EXAMPLE_BUILD_CMDS
+    $(MAKE) CC="$(TARGET_CC)" LD="$(TARGET_LD)" -C $(@D)
+endef
+
+define SOC_EXAMPLE_INSTALL_TARGET_CMDS
+   $(INSTALL) -D -m 0755 $(@D)/sel4-demo $(TARGET_DIR)/usr/bin
+endef
+
+$(eval $(generic-package))
diff --git a/package/soc_example/src/Makefile b/package/soc_example/src/Makefile
new file mode 100644
index 0000000000..e3672299ab
--- /dev/null
+++ b/package/soc_example/src/Makefile
@@ -0,0 +1,13 @@
+# build an executable named system-services-example from system-services-example.c
+CC=$(CROSS_COMPILE)gcc
+CFLAGS = -g -Wall -Wpedantic
+
+
+.PHONY: clean
+
+all: sel4_test.c 
+	$(CC) -o sel4-demo sel4_test.c
+
+
+clean: 
+	$(RM) sel4-demo
diff --git a/package/soc_example/src/ree_tee_msg.h b/package/soc_example/src/ree_tee_msg.h
new file mode 100644
index 0000000000..daa99d44e3
--- /dev/null
+++ b/package/soc_example/src/ree_tee_msg.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2021, Unikie
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+//#define SECURE_SNVM        1
+
+#define RNG_SIZE_IN_BYTES 32
+#ifdef SECURE_SNVM
+#define SNVM_PAGE_LENGTH  236
+#else
+#define SNVM_PAGE_LENGTH  252
+#endif
+#define USER_KEY_LENGTH   12
+#define DEVICE_ID_LENGTH  16
+#define PUF_CHALLENGE     16
+#define PUF_RESPONSE      32
+
+enum ree_tee_msg {
+    REE_TEE_STATUS_REQ = 0,
+    REE_TEE_STATUS_RESP,
+    REE_TEE_RNG_REQ,
+    REE_TEE_RNG_RESP,
+    REE_TEE_SNVM_READ_REQ,
+    REE_TEE_SNVM_READ_RESP,
+    REE_TEE_SNVM_WRITE_REQ,
+    REE_TEE_SNVM_WRITE_RESP,
+    REE_TEE_DEVICEID_REQ,
+    REE_TEE_DEVICEID_RESP,
+    REE_TEE_PUF_REQ,
+    REE_TEE_PUF_RESP,
+    INVALID = -1,
+};
+
+enum tee_status {
+    TEE_OK = 1,
+    TEE_NOK = -1,
+};
+
+
+
+struct ree_tee_status_req
+{
+    int32_t msg_type;
+    uint32_t length;
+};
+
+struct ree_tee_status_resp
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint32_t status;
+};
+
+struct ree_tee_rng_req
+{
+    int32_t msg_type;
+    uint32_t length;
+};
+
+struct ree_tee_rng_resp
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t response[RNG_SIZE_IN_BYTES];
+};
+
+struct ree_tee_deviceid_req
+{
+    int32_t msg_type;
+    uint32_t length;
+};
+
+struct ree_tee_deviceid_resp
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t response[DEVICE_ID_LENGTH];
+};
+
+
+struct ree_tee_snvm_read_req
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t user_key[USER_KEY_LENGTH];
+    uint8_t page_number;
+};
+
+struct ree_tee_snvm_read_resp
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t data[SNVM_PAGE_LENGTH];
+};
+
+struct ree_tee_snvm_write_req
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t user_key[USER_KEY_LENGTH];
+    uint8_t data[SNVM_PAGE_LENGTH];
+    uint8_t page_number;
+};
+
+struct ree_tee_snvm_write_resp
+{
+    int32_t msg_type;
+    uint32_t length; 
+};
+
+struct ree_tee_puf_req
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t request[PUF_CHALLENGE];
+    uint8_t opcode;
+};
+
+struct ree_tee_puf_resp
+{
+    int32_t msg_type;
+    uint32_t length;
+    uint8_t response[PUF_RESPONSE];
+};
diff --git a/package/soc_example/src/sel4_test.c b/package/soc_example/src/sel4_test.c
new file mode 100644
index 0000000000..3b94cff476
--- /dev/null
+++ b/package/soc_example/src/sel4_test.c
@@ -0,0 +1,338 @@
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "ree_tee_msg.h"
+
+#define SECURE 0
+#define PLAIN  1
+
+#define SEL4TEE "/dev/sel4com"
+
+static uint8_t tmp_key[] = {0x76, 0xa4, 0x58, 0xd1, 0x0e, 0xd7, 0xc0, 0x9b, 0xf5, 0x0d, 0xd2, 0xb9};
+
+static uint8_t test_data[] = {
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xCA, 0xFE, 0xAB, 0xBA, 0xCD,
+0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xCA, 0xFE, 0xCA, 0xFE, 0xAB, 0xBA, 0xFF
+};
+
+
+//#define SEL4TEE "/dev/null"
+
+static void print_menu(void)
+{
+    printf("\n\nWelcome seL4 test application\n");
+    printf("Select:\n");
+    printf("0 - Exit\n");
+    printf("1 - Random number from sel4 TEE\n");
+    printf("2 - Write data to sNVM\n");
+    printf("3 - Read Data from sNVM\n");
+    printf("4 - Device serial number\n");
+    printf("5 - PUF demo\n");
+    printf("\n");
+}
+
+static int handle_snvm_write(uint8_t *input_data, uint8_t *key, int handle, int page, int mode)
+{
+    ssize_t ret;
+    struct ree_tee_snvm_write_req req = {0};
+    struct ree_tee_snvm_write_resp resp = {0};
+    /* Open binary file for input data*/
+    if((!input_data) || (!handle) || (!key)){
+        return -EINVAL;
+    }
+
+    req.msg_type = REE_TEE_SNVM_WRITE_REQ;
+    if (mode == PLAIN) {
+        req.length = 252;
+    } else if (mode == SECURE) {
+        req.length = 236;
+    } else {
+        printf("Invalid mode\n");
+        return -EINVAL;
+    }
+    req.page_number = page;
+    memcpy(req.user_key, key, USER_KEY_LENGTH );
+    memcpy(req.data, input_data, SNVM_PAGE_LENGTH);
+
+    /*Write message to TEE*/
+    ret = write(handle, &req, sizeof(req));
+    if (ret != sizeof(req))
+    {
+        printf("Writing snvm write request failed\n");
+        return -EIO;
+    }
+
+    do {
+        ret = read(handle, &resp, sizeof(resp));
+    } while (ret < 0);
+
+    if (ret != sizeof(resp))
+    {
+        printf("Reading snvm write response failed: %lu \n", ret);
+        return -EIO;
+    }
+    return 0;
+}
+
+static int handle_snvm_read(int handle, int page, uint8_t *output, int mode)
+{
+
+    ssize_t ret;
+    struct ree_tee_snvm_read_req req = {0};
+    struct ree_tee_snvm_read_resp resp = {0};
+    req.msg_type = REE_TEE_SNVM_READ_REQ;
+    if (mode == PLAIN) {
+        req.length = 252;
+    } else if (mode == SECURE) {
+        req.length = 236;
+    } else {
+        printf("Invalid mode\n");
+        return -EINVAL;
+    }
+    req.page_number = page;
+    memcpy(req.user_key, tmp_key, USER_KEY_LENGTH );
+
+    ret = write(handle, &req, sizeof(req));
+    if (ret != sizeof(req))
+    {
+        printf("Writing snvm read request failed\n");
+        return -EIO;
+    }
+
+    do {
+        ret = read(handle, &resp, sizeof(resp));
+    } while (ret < 0);
+
+    if (ret != sizeof(resp))
+    {
+        printf("Reading snvm read response failed: %lu \n", ret);
+        return -EIO;
+    }
+    if (output)
+    {
+        memcpy(output, resp.data, SNVM_PAGE_LENGTH);
+    }
+    else
+    {
+        printf("\nsNVM page %d data:", page);
+        for(int i = 0; i < SNVM_PAGE_LENGTH; i++) {
+            printf("%2.2x ", resp.data[i]);
+        }
+    }
+    return 0;
+}
+
+static int handle_puf_request(int handle, uint8_t opcode, uint8_t *challenge, uint8_t *output)
+{
+    ssize_t ret;
+    struct ree_tee_puf_req req = {0};
+    struct ree_tee_puf_resp resp = {0};
+    req.msg_type = REE_TEE_PUF_REQ;
+    req.length = sizeof(req);
+    req.opcode = opcode;
+    memcpy(req.request, challenge, PUF_CHALLENGE );
+
+    ret = write(handle, &req, sizeof(req));
+    if (ret != sizeof(req))
+    {
+        printf("Writing puf request failed\n");
+        return -EIO;
+    }
+
+    do {
+        ret = read(handle, &resp, sizeof(resp));
+    } while (ret < 0);
+
+    if (ret != sizeof(resp))
+    {
+        printf("Reading puf response failed: %lu \n", ret);
+        return -EIO;
+    }
+
+    if (output)
+    {
+        memcpy(output, resp.response, PUF_RESPONSE);
+    }
+    else
+    {
+        printf("\nPUF data:");
+        for(int i = 0; i < PUF_RESPONSE; i++) {
+            printf("%2.2x ", resp.response[i]);
+        }
+    }
+    return 0;
+
+}
+
+static int handle_deviceid_request(int f, uint8_t *output)
+{
+    ssize_t ret;
+    struct ree_tee_deviceid_resp resp = {0};
+    struct ree_tee_deviceid_req req ={
+        .msg_type = REE_TEE_DEVICEID_REQ,
+        .length = 1,
+    };
+
+    /*Write message to TEE*/
+    ret = write(f, &req, sizeof(req));
+    if (ret != sizeof(req))
+    {
+        printf("Writing deviceid request failed\n");
+        return -EIO;
+    }
+
+    /*Read Response , polling*/
+    do {
+        ret = read(f, &resp, sizeof(resp));
+    } while (ret < 0);
+
+    if (ret != sizeof(resp))
+    {
+        printf("Reading device id message failed: %lu \n", ret);
+        return -EIO;
+    }
+
+    if (output)
+    {
+        memcpy(output, resp.response, DEVICE_ID_LENGTH);
+    }
+    else
+    {
+        /* print value*/
+        printf("\nDeviceID: ");
+        for(int i = 0; i < DEVICE_ID_LENGTH; i++) {
+            printf("%2.2x", resp.response[i]);
+        }
+    }
+
+    return 0;
+}
+
+static int handle_rng_request(int f, uint8_t *output)
+{
+    ssize_t ret;
+    struct ree_tee_rng_resp rngrsp = {0};
+    struct ree_tee_rng_req rngrq ={
+        .msg_type = REE_TEE_RNG_REQ,
+        .length = 1,
+    };
+
+    /*Write message to TEE*/
+    ret = write(f, &rngrq, sizeof(rngrq));
+    if (ret != sizeof(rngrq))
+    {
+        printf("Writing rng request failed\n");
+        return -EIO;
+    }
+
+    /*Read Response , polling*/
+    do {
+        ret = read(f, &rngrsp, sizeof(rngrsp));
+    } while (ret < 0);
+
+    if (ret != sizeof(rngrsp))
+    {
+        printf("Reading rng message failed: %lu \n", ret);
+        return -EIO;
+    }
+    if (output)
+    {
+        memcpy(output, rngrsp.response, RNG_SIZE_IN_BYTES);
+    }
+    else
+    {
+        /* print value*/
+        printf("\nRNG value:");
+        for(int i = 0; i < RNG_SIZE_IN_BYTES; i++) {
+            printf("%2.2x ", rngrsp.response[i]);
+        }
+    }
+    return 0;
+}
+
+int main(void)
+{
+    int f;
+    int choice;
+    int i = 1;
+    int page = 0;
+    int ret = 0;
+    int mode = 0;
+    f = open(SEL4TEE, O_RDWR);
+    if(!f)
+    {
+        printf("failed to open %s\n", SEL4TEE);
+        return -EIO;
+    }
+    while (i)
+    {
+        print_menu();
+        scanf("%d", &choice);
+
+        switch (choice)
+        {
+        case 0:
+            i = 0;
+            break;
+        case 1:
+                ret = handle_rng_request(f, NULL);
+            break;
+        case 2:
+            printf("\nEnter page to write: ");
+            scanf("%d", &page);
+            printf("\nEnter mode (1 PLAIN, 0 SECURE): ");
+            scanf("%d", &mode);
+            ret = handle_snvm_write(test_data, tmp_key, f, page, mode);
+        break;
+        case 3:
+            printf("\nEnter page to read: ");
+	        scanf("%d", &page);
+            printf("\nEnter mode (1 PLAIN, 0 SECURE): ");
+            scanf("%d", &mode);
+            ret = handle_snvm_read(f, page, NULL, mode);
+        break;
+        case 4:
+            ret = handle_deviceid_request(f, NULL);
+        break;
+        case 5:
+        {
+            uint8_t puf_challenge[PUF_CHALLENGE];
+            printf("\nEnter opcode for PUF: ");
+	        scanf("%d", &page);
+            /*set device serial as puf challenge*/
+            ret = handle_deviceid_request(f,puf_challenge);
+            if (ret)
+                break;
+
+            ret = handle_puf_request(f, page, puf_challenge, NULL);
+
+        }
+        default:
+            break;
+        }
+    }
+
+
+return ret;
+
+}
-- 
2.25.1

